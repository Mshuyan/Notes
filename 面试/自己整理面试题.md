# mysql

+ 简述悲观锁、乐观锁、共享锁、排他锁的概念和各自原理

  > + 乐观锁：每次拿数据并不会上锁，乐观的认为不会被修改，通过版本号控制
  >
  > + 悲观锁：每次拿数据都上锁，悲观的认为会被修改，通过共享锁、排他锁实现
  >   + 共享锁
  >     + 共享锁不排斥共享锁，排斥排他锁
  >     + select ... for share
  >   + 排他锁
  >     + 排他锁排斥任何锁
  >     + insert、delete、update、select ... for update

+ 简述行锁、页锁、表锁概念，以及增删改查语句什么时候产生什么锁

  > + 行锁：锁的是索引值，因为1个索引值对应多个数据行，所以看起来是锁住行
  > + 页锁：锁住一定范围内的数据
  > + 表锁：锁的是表中某个字段属性
  > + 增删改产生行锁，查询时如果索引条件生效产生行锁，否则产生表锁

+ 简述单列索引和联合索引概念，以及如何进行选择，联合索引查询时有哪些注意事项

  > + 单列索引就是在1个字段上建立索引
  > + 联合索引就是在多个字段上建立索引
  > + 当通过1个字段可以锁定记录时使用单列索引，当使用多个字段才可以锁定记录时使用联合索引
  > + 联合索引查询时字段顺序需要注意

+ explain重要列及含义

  > + 重要列
  >
  >   + type
  >
  >     在表中找到所需行的方式，性能排序：ALL, index,  range, ref, eq_ref, const, system, NULL
  >
  >   + key
  >
  >     用到了哪个索引
  >
  >   + rows
  >
  >     需要扫描多少行数据才能找到所需数据
  >
  > + 其他列
  >
  >   + id：数值越达越先执行，NULL最后执行，数值相同从上至下执行
  >   + select_type：语句类型
  >   + table：表名
  >   + possible_keys：涉及索引
  >   + key_len：使用的索引字段的最大可能长度，不是实际使用长度
  >   + ref：使用的索引关联了哪个字段
  >   + extra：额外信息

+ 优化手段

  > + 创建索引
  > + 语句
  >   + 避免使用`!=`
  >   + 使用`union`代替`or`，
  >   + [not] in
  >     + 能使用关联查询时避免使用[not] in
  >     + 子表大于外表时使用exists代替
  >   + `like`进行模糊查询时避免`%`开头
  >   + 避免在索引字段上使用内置函数或进行运算
  >   + 避免返回非必要字段，增加`I/O`压力
  >   + 避免隐式类型转换
  > + 代码中，避免循环执行sql

+ count(*)优化案例

  > + 语句：select count(*) from table where id > xxx
  >
  > + 优化后：select count(*) from table where id > xxx and inx > 0
  >
  >   inx是非空索引字段
  >
  > + 原理
  >
  >   使用id作为索引查询时，因为叶子节点存的是整条记录，所以统计总数时需要把所有数据拿出后统计，磁盘IO压力较大，效率较慢
  >
  >   加上inx字段时，走的是辅助索引inx，因为叶子节点存的是主键值，统计总数时需要把所有数据的主键值拿出统计，磁盘IO压力较小，效率较高
  >
  
  
